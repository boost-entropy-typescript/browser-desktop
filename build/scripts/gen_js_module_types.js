/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

const glob = require("glob");
const {
	lstatSync,
	existsSync,
	writeFileSync,
	readlinkSync,
	statSync,
	readFileSync
} = require("fs");
const { parse, resolve, basename } = require("path");

function getRootDir(currPath) {
	if (lstatSync(currPath).isFile()) {
		return getRootDir(parse(currPath).dir);
	}

	if (
		existsSync(resolve(currPath, "mach")) &&
		existsSync(resolve(currPath, "old-configure.in"))
	) {
		return currPath;
	} else {
		return getRootDir(resolve(currPath, ".."));
	}
}

function alphabeticalSort(a, b) {
	return a < b ? -1 : a > b ? 1 : 0;
}

function globAll(dir, filters) {
	return (filters || [""])
		.map((filter) => glob.sync(resolve(dir, filter)))
		.flat(1)
		.sort(alphabeticalSort);
}

function findOriginByName(module) {
	const rootDir = getRootDir(process.cwd());

	const name = basename(module);
	const paths = glob
		.sync(resolve(rootDir, "**", basename(module)))
		.filter((p) => !p.startsWith(resolve(rootDir, "obj-")));

	return paths.find((p) => p.endsWith(name));
}

function toPascalCase(text) {
	return text.replace(/(^\w|-\w)/g, (t) => t.replace(/-/, "").toUpperCase());
}

const rootDir = getRootDir(process.cwd());

async function importDotModulesRegistry() {
	const mod = await import(resolve(rootDir, "dot", "modules_registry.mjs"));
	const registry = mod.default;

	for (const [exportName, originPath] of Object.entries(registry)) {
		if (!existsSync(resolve(rootDir, "dot", originPath))) {
			console.error(
				`ERROR: No export for '${exportName}' found at '${originPath}' in modules_registry.mjs.`
			);
			process.exit(1);
		}
	}

	return mod.default;
}

let dotModules = {};

async function generateMozModules() {
	dotModules = await importDotModulesRegistry();

	let declaration = ``;
	let imports = new Set();
	let customImports = new Set();
	let resourceBindings = new Map();

	function declareModule(moduleURI, originURI, exportName) {
		const moduleType = toPascalCase(exportName);

		// Check if we have a dot module type for this module
		if (dotModules[moduleType]) {
			customImports.add(moduleType);
		} else {
			imports.add(toPascalCase(exportName));
		}

		return `declare module ${JSON.stringify(moduleURI)} {${
			dotModules[moduleType] ? `\n    import * as M from "./${dotModules[moduleType]}";` : ``
		}
    export const ${toPascalCase(exportName)}: ${
			dotModules[moduleType] ? `typeof M.` : ``
		}${toPascalCase(exportName)};
}\n\n`;
	}

	const binDir = glob.sync(resolve(rootDir, "obj-*", "dist", "bin"))[0];

	for (const module of globAll(resolve(binDir, "modules"), [
		"**/*.js",
		"**/*.sys.mjs",
		"**/*.jsm"
	])) {
		const isSymlink = lstatSync(module).isSymbolicLink();

		let origin;

		if (isSymlink) {
			origin = readlinkSync(module);
		} else {
			const match = findOriginByName(module, [parse(module).ext.substring(1)]);

			if (match) {
				origin = match;
			} else {
				console.warn("WARN: Could not find origin for", basename(module));
			}
		}

		if (!origin) continue;

		let relativeURI = origin;

		if (relativeURI.startsWith(resolve(rootDir, "dot"))) {
			relativeURI = "." + relativeURI.split(resolve(rootDir, "dot"))[1];
		} else {
			relativeURI = ".." + relativeURI.split(rootDir)[1];
		}

		const strippedModuleURI = module.split(resolve(binDir, "modules"))[1].substring(1);

		[
			`resource:///modules/${strippedModuleURI}`,
			`resource://app/modules/${strippedModuleURI}`,
			`resource://gre/modules/${strippedModuleURI}`
		].forEach((uri) => {
			const exportName = basename(module).split(".")[0];

			declaration += declareModule(uri, relativeURI, exportName);

			resourceBindings.set(uri, exportName);
		});
	}

	writeFileSync(
		resolve(rootDir, "dot", "mozbuild.d.ts"),
		`/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
/**
 * This file is automatically generated by the build system
 * to provide type definitions for modules that are not
 * written in TypeScript.
 * 
 * You should not edit this file directly, as it is generated by dot/build/scripts/gen_js_module_types.js */

// @ts-nocheck

/** Mozilla Module imports */
import type {
    ${Array.from(imports).sort(alphabeticalSort).join(",\n    ")}
} from "./third_party/dothq/gecko-types/lib";

/** Dot Browser Module imports */
${Array.from(customImports)
	.sort(alphabeticalSort)
	.map((imp) => `import { ${imp} } from "./${dotModules[imp]}";`)
	.join("\n")}

export interface AllMozModules {
    ${Array.from(imports)
		.concat(Array.from(customImports))
		.sort(alphabeticalSort)
		.map((i) => {
			const name = Array.isArray(i) ? i[0] : i;

			const type = dotModules[name] ? `typeof ${name}` : name;

			return `${name}: ${type}`;
		})
		.join(";\n    ")}

    [key: string]: any;
};

export interface AllMozResourceBindings {
    ${Array.from(resourceBindings.keys())
		.sort(alphabeticalSort)
		.map(
			(i) => `${JSON.stringify(i)}: ${JSON.stringify(toPascalCase(resourceBindings.get(i)))}`
		)
		.join(";\n    ")}

    [key: string]: any;
};

${declaration}`
	);

	console.log(`Generated declarations for ${imports.size} modules.`);
}

generateMozModules();
